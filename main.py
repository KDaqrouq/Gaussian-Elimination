# -*- coding: utf-8 -*-
"""sec04_100065701

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tcXsbY810LcavpLpUvaKtjTO23EZOIdb
"""

def Matrix(): # a function where the user inputs the coefficients aij and constants bi
  Matrix =[] # initializing an empty matrix

  print("Enter aij:") # asking the user to enter aij
  for i in range(3): # loop for 3 rows
    row = [] # intializing an empty row
    for j in range(3): # loop for 3 columns (coeffecints)
      aij = int(input()) # take input for aij
      row.append(aij) # appending the values for aij in the row
    Matrix.append(row)

  print("Enter bij:") # asking the user to enter bi
  for i in range(3): # loop for 3 times
    bij = int(input()) # asking the user to enter the values for bij
    Matrix[i].append(bij) # append constant bi to each row

  print("Augmented Matrix A:")
  for row in Matrix: # printing the matrix
    print(row)

  return Matrix # returning the matrix as the value of the function


def rowScale(A,r,k): # A function that takes the augmented matrix A, row number r, and a scalar k. This function scales row r of A by k
  A[r-1] = [item * k for item in A[r-1]] # scaling row r by k by using list comprehension

  print(f'''A after scaling row {r} by {k}:''') # printing matrix after scaling
  for row in A:
    print(row)
  return A


def rowSwap(A, r1, r2): #A function that takes the augmented matrix A, row number r1, and row number r2. This function swaps row r1 with row r2
  A[r1], A[r2] = A[r2], A[r1]  # Swapping rows

  print(f'''A after swapping row {r1+1} with row {r2+1}:''') # printing matrix after swapping
  for row in A:
    print(row)
  return A


def rowAddScale(A, r1, r2, k): # rowAddScale(A,r1,r2,k): A function that takes the augmented matrix A, row number r1, row number r2, and scaler k. This function scales row r1 of A and then is added to row r2 of A
  for j in range(4): # loop over every coefficient and constant
    A[r2][j] = A[r2][j] + k * A[r1][j]   # Adding k * row r1 to row r2

  print(f'''A after adding {k} * row {r1} to row {r2}:''') # Printing matrix after operation
  for row in A:
    print(row)
  return A

def gaussElimination(A):
  rows = len(A) # number of rows

  for i in range(rows):
    # Ensure each leading coeffecient is not 0
    if A[i][i] == 0: # checking if leading coefficient of each row is 0
      for k in range(i+1, rows): # if it is 0, check if the coeffecients of the row under it is not 0, and if so then swap rows
        if A[k][i] != 0:
          A = rowSwap(A,i,k)
          break
    if A[i][i] == 0:  # If after swapping, leading coefficient  is still zero, continue
      continue

    # Make every coefficient under the leading coefficient 0 using row operations
    for j in range(i+1, rows):
      scalar = -1*A[j][i]/ A[i][i] # scalar that we are multiplying to r1
      A = rowAddScale(A,i,j,scalar) # scaling r1 with scalar k then adding to all rows under r2 to get 0s under leading coefficient

  print("\nAugmented Matrix A after elimination:")
  for row in A:
    print(row)
  return A

augmented_matrix = Matrix() # calling function to take user input
A = augmented_matrix # assigning the user inputted function to A

row_Echelon_Form = gaussElimination(A) # reducing the user inputted matrix
print("\nAugmented Matrix in row echelon form:")
for row in row_Echelon_Form:
  print(row)

def backSubstitution(A):
    rows = len(A) # number of rows in matrix
    vars = len(A[0]) - 1  # Number of variables (excluding the last column which is b)

    solution = [0] * vars  # To store solutions or parametric vectors
    leading_vars = []  # Track leading variables
    free_vars = []   # Track free variables

    # Identify pivot variables and free variables indexes
    for i in range(rows):
        leading_index = False
        for j in range(vars): # Iterate through columns (excluding the constant column)
            if A[i][j] != 0: # If a nonzero coefficient is found mark the column as a leading coeffecient column
                leading_vars.append(j)
                leading_index = True
                break
        if not leading_index and A[i][-1] != 0: # if all the coeffecient variables are 0 but the constant is non zero then it is no solution (eg. 5 = 0)
            print("The system of linear equations has no solution.")
            return None  # No solution

    free_vars = [j for j in range(vars) if j not in leading_vars] # identifying free variables by checking if column is not stored within list of columns with a leading variable

    # If there are free variables then the ans is infinitely many solutions
    if free_vars:
        # Create dictionary to store parametric solution vectors
        parametric_solution = {var: [0] * vars for var in free_vars}

        # Solve system by back substituing from bottom to up
        for i in range(len(leading_vars) - 1, -1, -1): # iterate in reverse order
            row = leading_vars[i]
            sumofcoefficient = 0  # compute sum of known terms

            for j in range(row + 1, vars): # iterate through variables after column with leading variable
                if j in free_vars: # only consider fre variable
                    # add by how much the coefficient of the free variable is then multiply by parametric variable
                    sumofcoefficient += A[i][j] * parametric_solution[j][row]

            # finding a value for each leading variable
            solution[row] = (A[i][-1] - sumofcoefficient) / A[i][row] # (constant - sum of known free vars) / leading variable coefficient
            for free_var in free_vars: # store coefficient for free variable in parametric
                parametric_solution[free_var][row] = -A[i][free_var] / A[i][row] # stores the value of each free variable (in terms of leading variable) as a parameter

        # Assign free variables as parameters
        for free_var in free_vars: # loops over every free variable
            parametric_solution[free_var][free_var] = 1  # each free variable is a parameter

        # Print Parametric Solution
        print("This system of linear equations has infinite solutions:")
        parametric = " + ".join([f"s{var+1}*({', '.join(map(str, parametric_solution[var]))})^T" for var in free_vars]) # map turns the list of vector values into string then join combines them to produce desired output
        print(f"Solution: {parametric}")

    else:
        # Unique solution case (Back Substitution)
        for i in range(rows - 1, -1, -1): # iterate from last row
            sumofcoefficient = sum(A[i][j] * solution[j] for j in range(i + 1, vars)) # compute sum of known terms
            solution[i] = (A[i][-1] - sumofcoefficient) / A[i][i] # solve for the variable

        print("\nUnique Solution:")
        for index, val in enumerate(solution):
            print(f"x{index + 1} = {val}") # display each variables value

    return solution

backSubstitution(row_Echelon_Form) # calling the function to solve for x1,x2,x3 using reduced matrix

